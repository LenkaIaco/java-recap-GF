shell 			 	program that interprets your commands
terminal			window/app that displays command
command line interface(CLI)	interaction point where you type commands(sits inside a terminal and is powered by a shell)

Git Bash Terminal	The window you open when you click “Git Bash” (Git Bash window, Windows Terminal, IntelliJ’s built‑in terminal)
Git Bash Shell		Inside that window, the shell running is bash (a Unix-like shell; other programs: PowerShell, zsh, fish) 
Git Bash Command Line	The prompt where you type commands inside that shell

cd ~	navigate to home (user home folder of user Lenka in Windows, not C:, while C also has access to it, via its folder 'Users'-> 'lenka' )
up arrow / down arrow				scroll previously used commands one by one

!!	repeat previous command
! git	repeat last command which started with git
cd !$	use last argument of the last command in combo with current argument (e.g. las argument here was mkdir myfolder)

pwd		cur. dir. absolute address
which java	shows absol.path to a program (path to binary in Linux)
		c/..../Oracle/Java/javapath/java
where java 	full path to java executable: 		c/..../Oracle/Java/javapath/java.exe

echo sometext			prints text to command line
printf some\nformatted\ntext	considers format characters like \n
javac -d ../out Arrays/Excercises/*.java	“d- directory flag: compile into 'out' folder(pre-existing!), incl. directory structure, leading to java files" Works with both, abs/relat. paths. Compiler looks into the .java files -> package statement, and recreates the folders mentioned in the package statement If package statement is not first in the file, process will not compile. If package statement is missing, the file simply belongs to the default (src) package.

javac Arrays/Exercises/*.java			compile files(.class) into same folder as *.java. While the compiler still checks the package statement for correct placement, it does not consider it while deciding where to put the .class files. Simply puts them into same folder as the .java files.
javac */*.java */*/*.java 			while in out folder, compile every subfolder's java file + every sub-subfolder's java file

java package.statement.folders.Classname	run compiled class file from 1. folder where the subfolders mentioned in the 'package' statement are placed (a.k.a. fully qualified class name) 	2. or, add another location on the classpath: a location from where java should start searching for packages from 'package' statement: java -cp 

java -cp out fully.qualified.classname	run class file + add the out folder to classpath - where java should look for packages from the fully-qualified-class-name (=package statement packages + classname)

Creating JAR file:
The JAR file is being traditionally placed next to out and src folders (as out is for class files and src is for source code)

Before creating a jar file, consider whether you need a manually created manifest file first, or not. Once a jar is created, java automatically looks inside for manifest file, so any consequent modification requires creating a separate manifest file and re-creating the jar anew with the manual manifest reference:

A JAR is just a ZIP file with:
	your compiled .class files
	optional resources
	a META-INF/MANIFEST.MF file

The manifest we specify:
	Manifest-Version: 1.0   	//there exists only 1.0 version 
	Main-Class: StudentCounter	//fully qualified class name (same as package statement; for folders between source root and class, use dots: com.example.StudentCounter
	Class-Path: lib/gson.jar lib/commons-lang3.jar	// This line is optional because: lists only EXTERNAL dependencies - not java standard libraries(starting java.* and javax.*), they are already part of JDK/JRE. This does not affect compiler's classpath (javac ..), but runtime classpath (by JRE, but not the general one, just to run this JAR).
!!!AFTER THE ABOVE, MANIFEST NEEDS TO END WITH AN EMPTY LINE!!!
							// the default, but Java’s built‑in jar DOES NOT contain external dependencies within! Therefore, the Class-Path variable is needed (lib/gson.jar mentioned above is a path relative to the position of the JAR file itself(next to it)). 
However, you can build own zip file manually(which a jar essentialy is), I can create a "fat jar" ("uber JAR") which usually includes the external dependencies in it. When double-clicking a fat jar, JVM  opens the Jar - reads the Manifest - scans the JAR content for whichever classes it finds referenced. When your code references a class (e.g., com.google.gson.Gson), the class loader looks for that entry inside the JAR.

1. manual manifest:
jar cfm MyApp.jar MANIFEST.MF -C out . // 'c' create a jar  'f' specify jar file name (command executed in this folder) 'm' use given manifest file '-C out' Change directory into out. Then, include everything inside it ('.') ( content ++subfolders&subcontent! )
Following WILL result in ClassNotFoundException!!! jar cfm MyApp.jar MANIFEST.MF out/.   !!! because the JAR will be built including the path as actual directories out/./subfolderX   Therefore, use the flag -C to change into the directory where you want the JAR root to start(see above). To verify what is the JAR's folder structure, use the command:
jar -tf MyJar.jar 	// = list of files/folders:    -f means file  -t means list(table of contents)

2. automatic manifest:
jar cf JarExample.jar out/*.class	// 'c' create a file  'f' file name (look in out folder(no subpackages!)).



Error message: jar: command not found		// getting this error means that Java isn't installed // JDK's bin folder(containing jar tool) isn't on the PATH inside Git Bash. 
Reference the absolute path to the jar tool instead, or add jar's folder to gitbash PATH temporarily:

1. Use full path to jar tool instead of just jar reference:
"/c/Program Files/Java/jdk-17/bin/jar" cf MyJar.jar out/*.class 

2. Alternatively, only for this gitbash window session, add the jar location to gitbash's PATH:
export PATH="/c/Program Files/Java/jdk-17/bin:$PATH" adds the JDK’s bin directory in front of your existing PATH. If you would run the command without $PATH, it would replace the ENTIRE existing git path with just this folder location and the git commands like ls, git, bash, grep,... would not work anymore until the gitbash window gets closed. 
- If the JAR should be runnable per double-click, it needs to contain one main class reference per jar. So a project folder of independent classes with each a main method would work only if one separate main method class is used to launch all small classes mains. Otherwise, each file with main class needs its separate jar. If the jar does not need to be double-clickable, then it does not matter. 

After jar created, run it by double-click on the file, or by bash command: java -jar MyJar.jar

Creating a FAT JAR:
1. Fat jar manifest:
A correct fat‑JAR manifest contains no Class-Path entry at all, only: Manifest-Version: 1.0 and Main-Class: your.package.Main. 
The reason is that while running a Jar file, JVM automatically looks inside the JAR for all referenced dependencies. As external dependencies in the fat jar are already within the jar file (unlike with classic java-built jars, where they are outside it), there is no need for JVM scanning any additional folder outside that jar. 
2. Unzip all dependency JARs. Put them into one directory with the compiled class files. Then re-create the JAR.
	# unpack dependencies: 			jar xf lib/gson.jar
	# unpack original jar(if needed): 	jar xf MyApp.jar
3. Put all files in a folder together: mkdir temp
4. create JAR based on the manifest: jar cfm MyAppFat.jar ../MANIFEST.mf .		// I am positioned inside the temp folder, and manifest file is outside, next to it
5. Run the JAR: java -jar MyAppFat.jar

Editing JAR file:
If an error in the application is detected: 1. Correct java class 2. Re-compile correct classes 3. Re-create JAR with correct classes

ls -l		list of folders/files in cur.dir. With -l, details on files are shown
ls path/to/dir	list content in another dir.
ls -a 	(incl hidden folders)
ls -la	 long file info
ls -c 	(sorts: changed first)
cd + type first letters of folder + tab -> access folder
cd .. 	level up folder
cd + full path: /c/Users/Lenka

mkdir 		create folder
rmdir 		remove EMPTY dir.
rm -rf folder\with\content 	remove folder recursively forcefully - BYPASS TRASH, delete PERMANENTLY (alternatively use mv to move to trash, if you have the specific path to trash bin)
rm 1.txt 2.txt	remove file(s)
rm -f */*.java */*/*.java	as rm -r does not work with matching search patterns, the subfolder level needs to be specified (= del. any java file in 1st and 2nd level subfolders)		
printf "1\n2\n3" > file.txt	writes formatted(\n) text into existing/new file
touch file.txt 		creates file
nano newfile.txt 	creates/modifies file + reading/writing line-by-line in terminal (ctrl+s save changes, ctrl+x close /ctl+c cancel a file modif. command / ctrl+q quit writing mode)
less Myfile.txt 	also read file in terminal, but incl scrolling: arrowkeys scroll, q exit 

mv MyFile.txt MyFolder Destination		move file(s)/ directory(s)
mv old-folder-name new-folder-name		//rename folder / file
cp FileToCopy C:\Absolute\Or\Relative\Path.txt	
cp -avr MyFolder  Into\Address		-r incl. sub-folder content; -a archive(preserve permissions, timestamps); -v verbose (write out what has been copied-for verification)7
cp -avr . ../out 			copying everything from current(src) into out folder (creates out if not exists)
ja
man		manual w commands (?windows?)

history		commands used previously
history -c	 clear history

grep searchterm
sed "s/OLD/NEW/g"	search and replace in text for multiple use [] -> [aeiou]/y
cat Myfile.txt 		open file in terminal	
piping commands together:
cat list.txt | sort	
cat list.txt | head -8			only first 8 lines
cat list.txt | head -8 | tail -4	8 lines fed to tail cmd, displays last 4 of these 8
cat list.txt | wc			word count
cat list.txt | wc > another.txt		redirect word count into another file(pastes there)	
ls -l | sort | grep Local |sed "s/[oa]/i/g"		sorted files containing 'Local'-> 'Licil'



