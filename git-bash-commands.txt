shell 			 	program that interprets your commands
terminal			window/app that displays command
command line interface(CLI)	interaction point where you type commands(sits inside a terminal and is powered by a shell)

Git Bash Terminal	The window you open when you click “Git Bash” (Git Bash window, Windows Terminal, IntelliJ’s built‑in terminal)
Git Bash Shell		Inside that window, the shell running is bash (a Unix-like shell; other programs: PowerShell, zsh, fish) 
Git Bash Command Line	The prompt where you type commands inside that shell

cd ~	navigate to home (user home folder of user Lenka in Windows, not C:, while C also has access to it, via its folder 'Users'-> 'lenka' )
up arrow / down arrow				scroll previously used commands one by one

!!	repeat previous command
! git	repeat last command which started with git
cd !$	use last argument of the last command in combo with current argument (e.g. las argument here was mkdir myfolder)

pwd		cur. dir. absolute address
which java	shows absol.path to a program (path to binary in Linux)
		c/..../Oracle/Java/javapath/java
where java 	full path to java executable: 		c/..../Oracle/Java/javapath/java.exe

echo sometext			prints text to command line
printf some\nformatted\ntext	considers format characters like \n
javac -d ../out Arrays/Excercises/*.java	“d- compile into 'out' folder(pre-existing!), incl. folder structure leading to java files" Works w  both, abs/relat. paths. Compiler looks into the .java files -> package statement, and recreates the folders mentioned in the package statement If package statement is not first in the file, process will not compile. If package statement is missing, the file simply belongs to the default (src) package.

javac Arrays/Exercises/*.java			compile files(.class) into same folder as *.java. While the compiler still checks the package statement for correct placement, it does not consider it while deciding where to put the .class files. Simply puts them into same folder as the .java files.

java package.statement.folders.Classname	run compiled class file from 1. folder where the subfolders mentioned in the 'package' statement are placed (a.k.a. fully qualified class name) 	2. or, add another location on the classpath: a location from where java should start searching for packages from 'package' statement: java -cp 

java -cp out fully.qualified.classname	run class file + add the out folder to classpath - where java should look for packages from the fully-qualified-class-name (=package statement packages + classname)

Creating JAR file:

Before creating a jar file, consider whether you need a manually created manifest file first, or not. Once a jar is created, java automatically looks inside for manifest file, so any consequent modification requires creating a separate manifest file and re-creating the jar anew with the manual manifest reference:

A JAR is just a ZIP file with:
	your compiled .class files
	optional resources
	a META-INF/MANIFEST.MF file

The manifest we specify:
	Manifest-Version: 1.0   	//there exists only 1.0 version 
	Main-Class: StudentCounter	//fully qualified class name (same as package statement; for folders between source root and class, use dots: com.example.StudentCounter
	Class-Path: lib/gson.jar lib/commons-lang3.jar	// (list only EXTERNAL dependencies - not java standard libraries(starting java.* and javax.*), they are already part of JDK/JRE). This does not affect compiler's classpath (javac ..), but runtime classpath (by JRE, but not the general one, just to run this JAR)

1. manual manifest:
jar cfm MyApp.jar MANIFEST.MF -C out . // 'c' create a jar  'f' specify jar file name (command executed in this folder) 'm' use given manifest file '-C out' Change directory into out. Then, include everything inside it ('.') ( content ++subfolders&subcontent! )

2. automatic manifest:
jar cf JarExample.jar out/*.class	// 'c' create a file  'f' file name (look in out folder(no subpackages!)). If message "jar:command not found", bash cannot find the jar tool (Java isn't installed // JDK's bin folder isn't on your PATH inside Git Bash. Alternatively use full path to jar tool instead of just jar reference:
"/c/Program Files/Java/jdk-17/bin/jar" cf MyJar.jar out/*.class 
- Alternatively, only for this gitbash window session, add the jar location to gitbash's PATH:
export PATH="/c/Program Files/Java/jdk-17/bin:$PATH" adds the JDK’s bin directory in front of your existing PATH. If you would run the command without $PATH, it would replace the ENTIRE existing git path with just this folder location and the git commands like ls, git, bash, grep,... would not work anymore until the gitbash window gets closed. 
- If the JAR should be runnable per double-click, it needs to contain one main class reference per jar. So a project folder of indipendent classes with each a main method would work only if one separate main method class is used to launch all small classes mains. Otherwise, each file with main class needs its separate jar. If the jar does not need to be double-clickable, then it does not matter. 

After jar created, run it by double-click on the file, or by bash command: java -jar MyJar.jar

ls -l		list of folders/files in cur.dir. With -l, details on files are shown
ls path/to/dir	list content in another dir.
ls -a 	(incl hidden folders)
ls -la	 long file info
ls -c 	(sorts: changed first)
cd + type first letters of folder + tab -> access folder
cd .. 	level up folder
cd + full path: /c/Users/Lenka

mkdir 		create folder
rmdir 		remove EMPTY dir.
rm -rf folder\with\content 	remove recursively forcefully - BYPASS TRASH, delete PERMANENTLY (alternatively use mv to move to trash, if you have the specific path to trash bin)
rm 1.txt 2.txt	remove file(s)
printf "1\n2\n3" > file.txt	writes formatted(\n) text into existing/new file
touch file.txt 		creates file
nano newfile.txt 	creates/modifies file + reading/writing line-by-line in terminal (ctrl+s save changes, ctrl+x close /ctl+c cancel a file modif. command / ctrl+q quit writing mode)
less Myfile.txt 	also read file in terminal, but incl scrolling: arrowkeys scroll, q exit 

mv MyFile.txt MyFolder Destination		move file(s)/ directory(s)
mv old-folder-name new-folder-name		//rename folder / file
cp FileToCopy C:\Absolute\Or\Relative\Path.txt	
cp -avr MyFolder  Into\Address		-r incl. sub-folder content; -a archive(preserve permissions, timestamps); -v verbose (write out what has been copied-for verification)

man		manual w commands (?windows?)

history		commands used previously
history -c	 clear history

grep searchterm
sed "s/OLD/NEW/g"	search and replace in text for multiple use [] -> [aeiou]/y
cat Myfile.txt 		open file in terminal	
piping commands together:
cat list.txt | sort	
cat list.txt | head -8			only first 8 lines
cat list.txt | head -8 | tail -4	8 lines fed to tail cmd, displays last 4 of these 8
cat list.txt | wc			word count
cat list.txt | wc > another.txt		redirect word count into another file(pastes there)	
ls -l | sort | grep Local |sed "s/[oa]/i/g"		sorted files containing 'Local'-> 'Licil'



