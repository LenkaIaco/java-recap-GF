------------------------------------------------------------------
------------JAVA GENERAL------------------
------------------------------------------------------------------

which java	shows absol.path to a program (path to binary in Linux)
		c/..../Oracle/Java/javapath/java
where java 	full path to java executable: 		c/..../Oracle/Java/javapath/java.exe

------------------------------------------------------------------
------------JAVA BUILD ------------------
------------------------------------------------------------------
Build = producing something runnable

javac -d ../out Arrays/Excercises/*.java	“d- directory flag: compile into 'out' folder(pre-existing!), incl. directory structure, leading to java files" Works with both, abs/relat. paths. Compiler looks into the .java files -> package statement, and recreates the folders mentioned in the package statement If package statement is not first in the file, process will not compile. If package statement is missing, the file simply belongs to the default (src) package.

javac Arrays/Exercises/*.java			compile files(.class) into same folder as *.java. While the compiler still checks the package statement for correct placement, it does not consider it while deciding where to put the .class files. Simply puts them into same folder as the .java files.
javac */*.java */*/*.java 			while in out folder, compile every subfolder's java file + every sub-subfolder's java file (1 and 2 level down subfolders), vs:
javac **/*.java					compile every java file in 0 or more subfolders starting from here

java package.statement.folders.Classname	run compiled class file from 1. folder where the subfolders mentioned in the 'package' statement are placed (a.k.a. fully qualified class name) 	2. or, add another location on the classpath: a location from where java should start searching for packages from 'package' statement: java -cp 

java -cp out fully.qualified.classname	run class file + add the out folder to classpath - where java should look for packages from the fully-qualified-class-name (=package statement packages + classname)

Editing java class of an already compiled file:
If an error in the application is detected: 1. Correct java class 2. Re-compile correct classes


 	--------javac + cp and build tools-------------
javac -cp   => compiler, here you can look for already compiled classes(ext.dependencies) while compiling the rest.
Compiler uses classpath references for his standard activities - typechecking, verification methods and classes exist etc. The dependencies are not included in the compiled result in the out folder. During runtime, JVM has its own classpath for runtime purposes.

javac -cp lib/*;. -d out ./**/*.java 	; is path separator(If I don't create Jar but want to put current dir on classpath to run Main from it.)
javac -cp lib/* -d out src/**/*.java	compile src / 0+ subfolders/.java classes into 'out', while adding external dependencies(jars from lib) to the classpath, which the compiler is currently using to compile all related files along with this class. This puts ONLY external .jar files that are DIRECTLY in the lib folder on the classpath - NOT SUBFOLDERS

If I want to package an app manually with external dependencies (.e.g. testing imports junit = ext.d.), I need to either write a path to those jars within IntelliJ or download the jar manually from mvnrepository. Build tools like maven/gradle, apart from doing the whole build process also take care of resolving intra-dependency (compatibility) conflicts, so for bigger apps this is the current standard. Both mvn/gradle use mostly the maven repository to download dependencies, although maven file and gradle file reference the same files in their own format:
groupId:artifactId:version; for gradle vs maven:
1. 	dependencies { testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1' }  // gradle uses a Groovy  dynamic scripting language(DSL) (or sometimes Kotlin) for build scripts
2. 	<dependencies> 
		<dependency> 
			<groupId>org.junit.jupiter</groupId> 
			<artifactId>junit-jupiter-api</artifactId> 
			<version>5.8.1</version> 
			<scope>test</scope>
		</dependency> 
	</dependencies>
// maven uses xml  
Mvn repo - search libraries and download them as jar:
https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api/5.8.1

----------------------

Creating JAR file:
The JAR file is being traditionally placed next to out and src folders (as out is for class files and src is for source code)

Before creating a jar file, consider whether you need a manually created manifest file first, or not. Once a jar is created, java automatically looks inside for manifest file, so any consequent modification requires creating a separate manifest file and re-creating the jar anew with the manual manifest reference:

A JAR is just a ZIP file with:
	your compiled .class files
	optional resources
	a META-INF/MANIFEST.MF file

The manifest we specify:
	Manifest-Version: 1.0   	//there exists only 1.0 version 
	Main-Class: StudentCounter	//fully qualified class name (same as package statement; for folders between source root and class, use dots: com.example.StudentCounter
	Class-Path: lib/gson.jar lib/commons-lang3.jar	// This line is optional because: it lists EXTERNAL dependencies:
								- not java standard libraries(starting java.* and javax.*), they are already part of JDK/JRE. 
								- anything packaged within the jar will automatically be loaded by JVM at runtime, even if it is not in same folder than main class. 

----------Fat jars vs. standard jars----------

Every time we want to run an app, JVM needs to know the classpath to the app + classpath where related external dependencies are saved on the disk. 
During compilation, the compiler needs to know the classpath too, for its own typesafety and verification processes. 
These two classpath specifications happen independently from each other, individually in each stage:
	- during compilation stage(javac cp command or javac + manifest classpath) stage / or 
	- during running stage (java cp command or running the jar containing classpath info, or
	  running a fat jar without classpath but containing dependencies within) 
and regard only the classpath for this app(not local computer's environment classpath variables)

Packaging external dependencies(libraries, like junit for testing) within the jar makes it a FAT JAR. 
For fat jars, everything needed for running is inside the jar, so Class-Path property is not being used. 

For standard jars, ext. dep. are not part of the jar itself. You have 2 options:
1. Specify classpath at runtime: 
	For non-jars:  java cp lib/*;foldr/*.jar;. my.package.Main  //=run main while considering the classpath. Java does NOT automatically load Main on the classpath.
		       You need to add the current folder(where the main is) with '.' into the classpath, along with the external dependencies(jars in lib and foldr)
	For jars: 	java cp myapp.jar;lib/* my.package.Main	// Main is inside myapp.jar. Add the whole jar on classpath along with the java running command. The cp command paths are relative to CURRENT WORKING DIRECTORY
2. Specify MANIFEST's Class-Path variable: 
			Manifest-Version: 1.0   
			Main-Class: my.package.Main
			Class-Path: lib/first.jar lib/second.jar    // You need to list each jar individually, wildcards DO NOT work in manifest files(lib/*) ! The manifest classpath is relative to the JAR LOCATION AT RUNTIME:  app1/
 					  ├── app1.jar
					  └── lib/
   After which, the jar can be run with the jar command option: java -jar myapp.jar
   You have to keep the ext. libraries always at same location relative to the jar.
   Or you can use full path, not relative, but that is in praxis preventing the JAR from being used in another computer(=purpose of jars), so in praxis it is not used.


Editing JAR file:
If an error in the application is detected: 1. Correct java class 2. Re-compile correct classes 3. Re-create JAR with correct classes

*

----------JAR tradeoffs----------
- Standard Jars vs. reusable external libraries 
	Relative paths of ext.lib
	with traditional jars, if you have multiple jar-apps using same dependencies(e.g. junit for testing), 
	you need to keep all apps in the same folder, although necessarily not related to each other, 
	in order not to break the relative location logic. Upon moving an app elsewhere, the dependencies would need to 
	be copied to that different location, creating redundancies in your filesystem.
	Absolute paths of ext.lib
	that restricts JARs portability into another computer with its own filesystem structure, which is against JAR purpose

- FAT jars: you might have multiple apps in fat jars, each with possibly the same libraries, copied individually into each fat jar, a redundancy 

------------------------------------------------------------------
-----------JAVA DEPLOYMENT ------------------------------------
------------------------------------------------------------------
Deployment = run the built app somewhere (local, server, cloud, Docker, Kubernetes)

-----------Most common alternatives to JARs-------------------

Application Servers / WAR files  (deployment tool)
	Old‑school enterprise approach:
	1. Package your app as a WAR(compiled classes + resources + web.xml deployment file: configures servlets, filters, listeners etc.).
	Deploy into a server like Tomcat, Jetty, or WildFly (server runtimes)
	Server manages dependencies
	Strengths: Portable, no need for classpath/dependencies/JVM locally (not included while uploading, on app level)
	Weaknesses: Heavyweight: host server contains shared items:
						JVM + Tomcat/Jetty/Wildfly
						OS packages(native libraries and utility OS scripts, user permissions and networking configs(firewall, server-stored SSL certificates))
						Shared dependencies every app must conform to: shared config+shared logging+shared security systems+shared threadpools+shared classloaders
 	Used for legacy enterprise systems.

	Apps are tightly coupled with the server's architecture. Isolation advantage is missing - isolation in the context of the server vs apps and apps vs other apps hosted. 
	Apps are not isolated from the server's architecture, so their ability to run is linked tightly to the server and to each other
	 - because the hosted apps run the risk of breaking some of the shared dependencies while server gets updated/scaled/other apps are running on the dependencies. 
	   This defect would be shared - would affect all other hosted apps too.

	War is a zipped file(web app) containing:
	outside of WEB-INF folder = accessible to the browser(public): static resources (HTML, CSS, JS, images); JSP files; 
	In protexted WEB-INF folder(browser cannot see it): compiled classes+ your own libraries(no ext.dep.!)+config files(web.xml, optionally config files *.properties or *.xml)
	myapp.war
	├── index.html
 	├── images/
 	├── css/
	├── js/
	└── WEB-INF/
   	    ├── web.xml
   	    ├── classes/
   	    └── lib/

	The old model: one heavy host, many lightweight apps. Disadvantage: high risk host breaks(updating server risk dependency version,
	something goes wrong, scaling requires setting up another server manually), then all apps don't function - no isolation.

	
	2. Docker(packaging and runtime tool, rather than a deployment tool)
	Docker is a containerized runtime tool. Docker(docker container with the app+co.) can be deployed on a server or a cloud later:
		a) Install docker on a server(.e.g. on a physical machine)
		b) Run docker inside a virtual machine
		c) Cloud providers provide the option to run your docker container for you:
			- Azure Container Apps, Google Cloud Run ...
			- Cloud providers that run Kubernetes for you(no need to configure any kubernetes): Azure Kubernetes Service, AWS EKS (Kubernetes), Google Kubernetes engine 

		d) Kubernetes can be both used for cloud deployment(c), or a standalone orchestration layer(d) - depending how you use it.
		   Kubernetes = the orchestration layer that schedules, scales, and manages containers. Kubernetes technology can run on server, cloud, VMs, laptops. 

	Package your app + dependencies + JVM into a container image.
	Strengths: No need for classpath
	Weaknesses: Requires Docker runtime, Larger images - JVM+dependencies needed as well

	The new model: lightweight host, self-contained(dependencies, JVM, OS packages,server runtime, config files) apps bigger in size but fully isolated systems(runtimes+tools+configs) and more scalable. Prevents risk of one app breaking another or a part of server breaks and affects all apps running.

--------------------------------------			
This does not affect compiler's classpath (javac ..), but runtime classpath (by JRE, but not the general classpath, just classpath to run this JAR).
!!!AFTER THE ABOVE, MANIFEST NEEDS TO END WITH AN EMPTY LINE!!!
							// the default, but Java’s built‑in jar DOES NOT contain external dependencies within! Therefore, the Class-Path variable is needed (lib/gson.jar mentioned above is a path relative to the position of the JAR file itself(next to it)). 
However, you can build own zip file manually(which a jar essentialy is), I can create a "fat jar" ("uber JAR") which usually includes the external dependencies in it. When double-clicking a fat jar, JVM  opens the Jar - reads the Manifest - scans the JAR content for whichever classes it finds referenced. When your code references a class (e.g., com.google.gson.Gson), the class loader looks for that entry inside the JAR.

1. manual manifest:
jar cfm MyApp.jar MANIFEST.MF -C out . // 'c' create a jar  'f' specify jar file name (command executed in this folder) 'm' use given manifest file '-C out' Change directory into out. Then, include everything inside it ('.') ( content ++subfolders&subcontent! )
Following WILL result in ClassNotFoundException!!! jar cfm MyApp.jar MANIFEST.MF out/.   !!! because the JAR will be built including the path as actual directories out/./subfolderX   Therefore, use the flag -C to change into the directory where you want the JAR root to start(see above). To verify what is the JAR's folder structure, use the command:
jar -tf MyJar.jar 	// = list of files/folders:    -f means file  -t means list(table of contents)
jar tf MyJar.jar	// does the same

2. automatic manifest:
jar cf JarExample.jar out/*.class	// 'c' create a file  'f' file name (look in out folder(no subpackages!)).



Error message: jar: command not found		// getting this error means that Java isn't installed // JDK's bin folder(containing jar tool) isn't on the PATH inside Git Bash. 
Reference the absolute path to the jar tool instead, or add jar's folder to gitbash PATH temporarily:

1. Use full path to jar tool instead of just jar reference:
"/c/Program Files/Java/jdk-17/bin/jar" cf MyJar.jar out/*.class       // the apostrophs "full/path/jar" are necessary because Program Files is a folder name with a SPACE; without "", bash assumes that the path equals /c/Program only - and rest of command regards something else

2. Alternatively, only for this gitbash window session, add the jar location to gitbash's PATH:
export PATH="/c/Program Files/Java/jdk-17/bin:$PATH" adds the JDK’s bin directory in front of your existing PATH. If you would run the command without $PATH, it would replace the ENTIRE existing git path with just this folder location and the git commands like ls, git, bash, grep,... would not work anymore until the gitbash window gets closed. 
- If the JAR should be runnable per double-click, it needs to contain one main class reference per jar. So a project folder of independent classes with each a main method would work only if one separate main method class is used to launch all small classes mains. Otherwise, each file with main class needs its separate jar. If the jar does not need to be double-clickable, then it does not matter. 

After jar created, run it by double-click on the file, or by bash command: java -jar MyJar.jar
jar
Creating a FAT JAR:
1. Fat jar manifest:
A correct fat‑JAR manifest contains no Class-Path entry at all, only: Manifest-Version: 1.0 and Main-Class: your.package.Main. 
The reason is that while running a Jar file, JVM automatically looks inside the JAR for all referenced dependencies. As external dependencies in the fat jar are already within the jar file (unlike with classic java-built jars, where they are outside it), there is no need for JVM scanning any additional folder outside that jar. 
2. Unzip all dependency JARs. Put them into one directory with the compiled class files. Then re-create the JAR.
	# unpack dependencies: 			jar xf lib/gson.jar
	# unpack original jar(if needed): 	jar xf MyApp.jar
3. Put all files in a folder together: mkdir temp
4. create JAR based on the manifest: jar cfm MyAppFat.jar ../MANIFEST.mf .		// I am positioned inside the temp folder, and manifest file is outside, next to it
5. Run the JAR: java -jar MyAppFat.jar

--------------------------------------------------------
