All methods(Files.readAllLines, Path.of, Paths.get) are part of the newer java.nio package. 
java.io   → Old, stream‑based, blocking I/O (Java 1.0)
java.nio  → Newer, buffer‑based, non‑blocking I/O (Java 1.4+), plus modern file APIs (Java 7+)
------------------------------------
1. src = 'source root' - directory where Main class with main method is located, meant for source code
2. e.g. MyProject = 'project root' (whichever I indicate at project opening in intellij), which may contain both source code folder and resource folder and config files, and 
3. 'module root': directory where IntelliJ is running the program from, default is 'module root'(top‑level directory of that module(content root). 
	IntelliJ 
	 1. uses:
		A) Imported projects: the directory containing build.gradle
		B) Project you create via IntelliJ: will be the folder you select for creating your project
	2. places:
		.iml file into that directory to indicate this is the module root; either inside the directory directly or within .idea folder
4. Working directory:  directory where JVM launches the program from. IT IS THE BASE FOLDER FOR RELATIVE FILESYSTEM ACCESS:
	Paths.get("data/input.txt");  ---> workingdirectory/data/input

Working directory Can be:

- current directory(.) - JVM will automatically look for main class to launch here
		Java MyProgram  //this command is run from the current directory
- classpath-indicated file. Classpath can be one of 3 options:
				A/  not specified -> JVM takes current directory (.) and looks for main class here
				B/  via MANIFEST file + combined with running the jar:   java -jar MyApp.jar
				C/  via java -cp command:   
					java -cp out/production/myapp com.example.Main   
				 	//top-level directory where the package structure begins:
						out/
 						 production/
  						  MyApp/        ← this directory
     						   com/
      						    example/
       						     Main.class
 Here, JVM will look into subfolders for:
	- com/example/Main.class
	- any .class files under that root
	- any resources inside that same root (e.g., config.properties)



--------------------------------
//With input and output files using FileIO operations(copy, write), NEVER put the files inside the src! The reason is, that, depending on whether you launch the app from a jar(java starts inside zipped out folder, which is an equivalent of src folder, only with compiled classes), or from IntelliJ(here you need to reference one level up - also src folder in the path! as the project root folder is above src), the FileIO path will work differently depending on where you launch it from.
// java does not know the exact path to this class. However it is being launched within a java application (e.g. a jar). 
So java knows the directory of this application (JVM's current working directory). Therefore, starting from this directory, all the subfolders need to be named that lead to the class you are looking for, that is located within the folder structure that this application has. If the path is not part of the application folder, but located elsewhere, absolute path to the file needs to be provided,e.g.:

------------------------------------

List<String> l;  //  files are read into a list, because at the point of reading the file, the size of the resulting list is not known

try{
   l = Files.readAllLines(Path p);     // the list will not be reachable outside the try-catch block, unless it is declared outside of it + initialize it, or:
} catch (IOException e) {
   System.err.println("Unable to read source file");
	return;						// if List is not initialized outside try-catch, return if error; otherwise it is not possible to work with the list after try-catch finalizes
}
Paths.get() and Path.of() have the same effect:
Path p = Paths.get("subfolder1/subfolder2/file.txt");	
	
Path p = Path.of("subfolder1/subfolder2/file.txt");
	Path.of("subfolder1","subfolder2","file.txt");



Path p = Paths.get("C:/data/config/file.txt");
	Paths.get("C:/","data","config","file.txt")   //the C:/ is a name of the directory, therefore actual slash needs to be inserted to reproduce the absolute path above


------------------------------------
When working with methods that potentially throw an exception, you are working with them within another method(main, or your own other method). The current method would either have to declare the throwing possibility (e.g. you modify main to "public static void main(String[] args) throws IOException {}"), or the throwing method needs to be wrapped in a try-catch block to replace throwing with some other action:

COPYING

        try {
            System.out.println(Files.copy(Path from,Path to);				//without copy option, default is StandardCopyOption.COPY_ATTRIBUTES (a pre-existing file needed)
       										// The paths should be written relatively to where the java application is being launched from. The destination path especially if a file is supposed to be created by the running program, should be ideally next to the src folder, not inside it, because: In case the application would be later packaged into a jar and launched from the JAR position, the destination file would not be found in the original position relative to src folder, but relative to out folder.
 } catch (IOException e) {
            e.printStackTrace();
        }

        try{
            Files.copy(p1,p2,StandardCopyOption.COPY_ATTRIBUTES ); 		// CREATES a file + copies contents into it. THROWS ERROR for already existing target files!!
				StandardCopyOption.REPLACE_EXISTING		// if a file exists, replaces its contents
        } catch(IOException e){
            System.err.println("target file already exists"); 			// prints error message, but still returns (opposed to throwing error, where program flow stops)
            return false;
        }



WRITING

	 try {
            Files.writeString(Path targetFile, String s); // If  StandardOpenOption is omitted at the end, like here, it behaves as StandardOpenOption.CREATE 
        } catch (IOException e){
            System.out.println("Unable to write file: "+ p);
        }


	 try {
            Files.write(Path targetFile, List l, StandardOpenOption.APPEND); // List extends iterable, array does not. 
        } catch (IOException e){
            System.out.println("Unable to write file: "+ p);
        }


        try {
            Files.write(pathToTargetFile, List l);			// if no standard open option is chosen, the method will automatically behave as if CREATE was chosen
        } catch (Exception e ) {
            System.err.println("Unable to write file: my-file.txt");
        }



// There are compile-time and runtime exceptions. Compile-time exceptions need to be handled, in-code (try-catch) or declared at the method level (method signature + throws ExceptionX {} ), otherwise the code won't compile. These exceptions are usually connected to external failures, therefore they are designed to be handled(anticipated) as possible scenarios in the code.
Compile-time exceptions: IOException, ClassNotFoundException, SQLException

Runtime exceptions - code logic errors, not needed to be handled because they are originating from code errors which (java expects) need to be fixed for the program to work correctly: 
- These all extend RuntimeException:
- NullPointerException (variable operation invoked at null object), UnsupportedOperationException (modify immutable list), ArithmeticException (divide by 0), IndexOutOfBoundsException (access array at invalid index), IllegalArgumentException, 
OutOfMemoryException: allocating a contiguous block of memory not availabe: int[] arr = new int[Integer.MAX_VALUE];
		      infinite element addition: while (true) { list.add(new byte[1024 * 1024]); // add 1 MB blocks forever 
		


Throwable
 ├── Exception
 │     └── RuntimeException			//Both RuntimeException and Error are considered unchecked
	└── other CHECKED exceptions
 └── Error

------------------------------------
StandardCopyOption.COPY_ATTRIBUTES  - Throws FileAlreadyExists (subclass of IOException) ! For non-existing target files(to be created). Copy contents incl. timestamps, permissions
StandardCopyOption.REPLACE_EXISTING - CREATES FILE IF NOT EXISTING. And replaces contents if already existing

StandardOpenOption CREATE</th>
* new file is created or
* existing file content is overwritten
StandardOpenOption APPEND
* File MUST EXIST ahead otherwise IOException!
* Write to the end of the file instead of overwriting from the beginning
StandardOpenOption WRITE		
* starts writing at 0 but does NOT TRUNCATE THE FILE!
* File MUST EXIST ahead otherwise IOException!
* overwrites content unless combined with APPEND.

StandardOpenOption CREATE_NEW
Create a new file, but fail if it already exists. This prevents accidental overwrites.
StandardOpenOption READ
Open the file for reading.
