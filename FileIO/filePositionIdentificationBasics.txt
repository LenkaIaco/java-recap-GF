There are 2 ways how to refer to a position of a file:
- Relative to a directory structure (1. relative to a folder on PC(which is runtime working directory and app is launched from) 2. absolute full path to a file on this concrete PC)
- Position of a file related to the directory 1. starting from classpath root or 2. directory of invoking class - relative to its folder's position, within the classpath:

ATTENTION while working in IntelliJ - classpath root is NOT the parent folder (e.g. MyProject), so the reference starting '/' will NOT work as in example below! 
Therefore, please work with the version without starting '/'
Instead, IntelliJ has multiple roots: src, resources, test, compiled into an output - this compiled output is the classpath:
src/main/java
src/main/resources
src/test/java
src/test/resources
	- ENSURE YOUR PROJECT FOLLOWS THIS STRUCTURE, 
	- FILES UNDER PARENT PROJECT FOLDER BE AUTOMATICALLY ADDED FOR COMPILATION

- If your project DOES NOT follow the structure, IntelliJ usually marks ONE folder as the source root - either parent folder, or src - depending how you name them.
Visually, the project tree section in IntelliJ marks ONE folder in BLUE which is the SOURCE ROOT. 
ANYTHING OUT OF THIS FOLDER WILL NOT BE CONSIDERED into compilation, unless you modify source root settings manually!


    Calling resource without '/' at the start:  
    Inputstream is = Logs.class.getResourceAsStream("config.txt");     //  classpathroot/../logsdirectory/config.txt
    Calling resource starting with '/' :
      Logs.class.getResourceAsStream("/config.txt")	// classpathroot/config.txt
      

The relative directory positioning(1) is easier to write in code, but the relative position changes based on where you start the application from. For relative positions, it changes in IDE vs JAR vs command line launch of application. And the absolute positions work only on one specific computer. 
 
The position relative to classpath(2) works both for IDE and JAR the same(unlike it is with directory structure references) - but it WORKS ONLY for READING PROJECT FILES
With the JAR, the application is portable among any type of computer with java runtime installed. So it is a recommended solution to use in a program, as it does not create unintended side effects or limit the application to one environment.

------------------------------------------------
Examples
------------------------------------------------
getUniqueIpAddresses(Path filePath) below works with relative/absolute file paths based on local directory structure. Relative - in IntelliJ, the project folder above the src folder(
project parent folder = source root) for IntelliJ ).
However, the directory root position would not be the same, if the app is started from a JAR (which zips everything within 'out' folder for JAR(out=app root)).
So the application would start either in IntelliJ only, or in JAR only, if this referencing is used.

The second method getIPsFromClasspath is working with classpath position instead of the folder structure position.
IntelliJ puts on classpath both java files in src + src/resources folders.
So the source files, in order to be found via classpath, need to be either:
     - in the same folder as this java class(because you are calling its classpath position)
     - or in the classpath root under resources, which can also be referred as a starting classpath point(root)

The classpath method will work both with JAR app and IntelliJ startup the same, so it helps portability of the app.
    
/home/username/myapp/logs_copy.txt        (Linux, macOS)
C:\Users\Username\myapp\logs_copy.txt     (Windows)

Path specification using CLASSPATH:
    1. Absolute reference: starting from source root
    If the file is located separately from current java class, e.g. under resources folder(a.k.a classpath's root),
    then under logs/myfile.txt, use absolute reference starting with slash(/):
    Logs.class.getResourceAsStream("/logs/myfile.txt")      // first is '/' == classpath root reference(a.k.a. resources);

    2. Relative reference: folder of current java class
    Logs.class.getResourcesAsStream("myfile.txt")          // looks in same folder as current java class for the "..."
    The JVM looks at the class loader of Logs.class(every loaded class has a class loader).
    That class loader knows the classpath: JVM delegates to this class loader, to search the classpath entries for "myfile.txt"
    This method operates with try-with-resources BufferedReader built on InputStreamReader consuming an InputStream.
    BufferedReader.close() automatically calls close() on the underlying InputStreamReader, which then closes the underlying InputStream.
    So you only need to close the outermost resource.

	---Why close file resources?---
	A program running on OS has a limited number of files it can ask OS to hold open. 
	As each open file costs OS resources, if program exceeds its limit, 
	OS refuses opening and Java throws 'FileIOException: too many open files'
	OS has a table with open files, each assigned an integer (file descriptor) that marks it.
	So file descriptor is a pointer to an open file resource - on the OS table of open files.
	When java asks OS to open a file, OS responds with the file descriptor number.
	Java creates a stream and stores the file descriptor in it.
	When the stream is closed, java asks OS to release the resource under the file descriptor number.

	FileReader is a character stream (text files)
	InputStreamReader is a byte stream (binary resources like images, PDFs, DOCX, audio, video, ZIP, EXE, Serialized Java objects (.ser)*)
	BufferedReader is a buffered character stream (text resources)

* serialization is the process of transforming java file into bytes. It can be used to send files via network, stored in db, transferred between JVMs, or cached
Deserialization = transforming back to java object

----------------------------------------------------------------------------
Example 1: getUniqueIpAddresses() works with directory references via Paths:
----------------------------------------------------------------------------
public static List<String> getUniqueIpAddresses(Path filePath) {
        List<String> l = new ArrayList<>();
        try {
            l = Files.readAllLines(filePath);
        } catch (IOException e) {
            return new String[0];
        }
	return l;
}

----------------------------------------------------------------------------
Example 2: getIPsFromClasspath() uses classpath via .class().getResourceAsStream() 
(there are other getResource() methods, but they do not work with JARs properly)
----------------------------------------------------------------------------
 public static List<String> getIPsFromClasspath(String filename) {
        InputStream is = Logs.class.getResourceAsStream(filename);	// the java 'classname.class' needs to be used if used within a static context(method); otherwise, this().class() works too
        List<String> list1;
	List<String> list2 = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(is))) {
            list1 = br.lines().toList(); // UNMODIFIABLE LIST !!!
	    list2 = new ArrayList<>(list1);  // MODIFIABLE
        } catch (IOException e) {
            System.err.println("Source file not found");
            return new String[0];
        }
	return list 2;
}

----------------------------------------------------------------------------
Example 3: Write from file to file
Target file should be positioned independently from how the application is launched(IDE, JAR),
always appear on the same spot -  a relative path to a System.getProperty("user.home"), in windows: C:\Users\<YourUsername>
C:\Users\Username\myapp\logs_copy.txt     (Windows)
/home/username/myapp/logs_copy.txt        (Linux, macOS)
----------------------------------------------------------------------------

   public static void decryptDoubledByClassPath(String filename){

// Step1: reading from source

    List<String> list;

        InputStream inputStream = Doubled.class.getResourceAsStream(filename);

        try(BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))){
            l = br.lines().toList();
        } catch (IOException e){
            System.err.println("File not found");
            return;
        }

//Step 2:WRITING using System property(below) CANNOT happen using ANY location within the running app!
This design decision comes from the fact that the system property is resolved dynamically, based on CURRENT RUNNING PROCESS DIRECTORY
	which Windows silently redirects Documents → OneDrive/Documents !
and the working directory ends up being a virtualized OneDrive path, instead of the actual physical Documents folder

Such a location within the OneDrive cannot be modified while the application is running because of system security checks.
Windows OneDrive locks files as read only during application runtime and any Write attempt will result in SecurityException!

	However, if manual java class File with a hardcoded path is used, you bypass OneDrive’s virtualization and hit the real file system:
	File file = new File("myFile.txt");
	try{
            Files.write(file.toPath(), list); 
	} catch ....


// For writing using system property file position relative to the dynamically resolved(= later redirected) System.getProperty("user.home") which is \C:\Users\lenka
	- Use BACKSLASH '\' instead of normal slash, to mirror the system property logic and prevent format errors:
	- ADD EXTRA ESCAPE BACKSLASH so that backslash is considered an actual character:

String myRelativePath =  "\\Documents\\JavaProjects\\java_recap_gf\\TodoApp\\todoList.txt"

            Path targetPath = Path.of(System.getProperty("user.home"),myRelativePath);  
        try{
            Files.write(targetPath, list);
        } catch (IOException e){
            System.err.println("Writing not successful");
            return;
        }

        System.out.println("Writing succesful");
    }

----------------------------------------------------------------------------
Example 4: Copy by classpath accepts InputStream instead of source path:
----------------------------------------------------------------------------
 public static boolean copyByClasspath (String sourceFile, String targetFile){
        InputStream sourceIS = CopyFile.class.getResourceAsStream("sourceFile.txt");

        Path targetPath = Paths.get(System.getProperty("user.home"),targetFile);
        try{
        Files.copy(sourceIS,targetPath);//without specifying, the method behaves as if StandardCopyOption.COPY_ATTRIBUTES
        } catch (IOException e){
            System.err.println("Writing not successful");
            return false;
        }
        return true;
    }
