


HTTP+TLS = HTTPS  (TLS= encryption layer protecting a socket communication by encrypting the communication flowing through socket(plaintext bytes("Hello") -> encrypted bytes(8F A2 3C 91 7B ...)
	One of the ways how microservices can communicate is REST (HTTP/HTTPS); but there are other ways(GraphQL(HTTP), gRPC(HTTP/2+photobuf(instead of JSON in rest)+TLS)
	TLS is used also for wrapping:
			- communication in plain TCP (legacy systems, or simple custom binary protocols built on top of TCP, or using frameworks(like Netty - Java framework for 					building servers and clients for network communication. Highâ€‘level framework built on top of NIO to make it easier to develop networked applications)
			- communication between java driver and database(MySQL, PostgreSQL, OracleDB) over TCP w TLS + each db has its own protocol which the jdbc driver(relational dbs, sql) or other java drivers(no SQL dbs like MongoDB) implements
			- for message queues(Kafka, RabbitMQ), often asychnronously using a message broker(messaging protocol) 
				custom protocols on top of TCP (custom binary formats, game servers, financial trading systems)

		A Java driver(a library that drives communication between) could also mean:
				a driver for a message queue (Kafka client, RabbitMQ client)
				a driver for a NoSQL database (MongoDB Java driver, Redis Java client)
				a driver for a cloud service (AWS Java SDK)(java driver implements whatever protocol the cloud service exposes â€” usually HTTPSâ€‘based APIs)
				a driver for a hardware device (rare, but possible) (various protocols; essentially a driver in this context is a Java wrapper around a native(C/C++)  					library that speaks the deviceâ€™s protocol)

Your Application Protocol (HTTP, gRPC, custom binary, etc.)
                â†“
              TLS
                â†“
              TCP
                â†“
             Network
	


------------------TCP-------------------------
Transpor layer protocol for establishing a connection between 2 points(devices) 
It is so widespread because it provides a reliable verified (and ordered) connection:
Reliable Connection: before sending data, it performs a threeâ€‘way handshake - to establish a connection
Reliable Logistics: Breaks data into packets and reassembles later in correct order

Secure commection establishment + (complete reliable data transport) + proper connection closing by means of HANDSHAKES:
Closing: fourâ€‘step handshake (FIN â†’ ACK â†’ FIN â†’ ACK) - ensures closed properly at both ends + feedback
Dispatch: DATA â†’ ACK â†’ DATA â†’ ACK â†’ â€¦  (+numbering data packets): 
	* acknowledgments (ACKs) after arrival, contain the number offset the expected in the next package. Ack enables Redispatch if(next is) lost. 
	* Numbering enables correct reassembly. If any bytes in the sequence are missing, requests retransmission of that packet(part) of bytes)
	* Retransmission timeout: 1. Timeouts (no ACK arrives in time)
	  If the sender sends a segment with sequence number X  and does not receive an ACK â‰¥ ð‘‹+segmentÂ length  within a certain time window, it assumes:
	  	â€œThis packet or its ACK was lost.â€
	  Then it retransmits that segment.

Opening: Three-way handshake (SYN â†’ SYNâ€‘ACK â†’ ACK) synchronisation. Both side agree on starting with same sequence numbers, prevents data corruption.

Usage(built on top):
	web browsing
	email
	file transfer
	remote access
	streaming

Offsets(serial number use) are not used for encryption, but for offset: â€œThis chunk of data starts at byte X in the stream.â€
Packet A (bytes 0â€“499) (offset number 0)
Contains 500 bytes in a sequence 0-499

Packet B (offset number 500 -> bytes 500â€“999)
contains also 500 bytes in a sequence !



	