JRE - only running already complied java classes (git bash 'java' command). 
	- Contains JVM, standard java libraries, security config files (properties, security, permissions etc). 
	- contains runtime tools
		JRE’s bin folder contains only runtime tools like:
		java → runs programs
		keytool → create and manage (keystores) files that store certificates and cryptographic keys(for SSL/TLS, HTTPS, code signing, and secure communication.)
		policytool -> The configuration files define what Java code is allowed to do — file access, network access, system operations — but they only matter when Java is running in 		a restricted sandbox, which is uncommon today(old sandboxed apps, being phased out); nowadays java runs on full permissions just like any other normal program.
		other tools
	- Contains all java standard libraries (packaged in a module(Java 9+) or as rt.jar)


JDK = JRE + development tools.
	- Contains everything mentioned above, with JRE
	- Additionally, development and debugging tools:
		Inside the JDK’s bin folder, you’ll additionally find:
			javac → compiles .java → .class
			javadoc → generates documentation
			jar → builds JAR files
			jdb → debugger

IntelliJ shortcuts:
sout + tab                      System.out.println()
main + tab			public static void main(String[] args){}
ctrl + alt + l                  automatic formatting
ctrl + click class name         opens documentation (class info)

char[] arr = new char[5];
int[] consumes less (4 bytes) memory than Integer[] (24–32 bytes: reference, object, int inside,padding-The JVM tries to place objects at memory addresses divisible by 8. If the object’s size is not a multiple of 8, the JVM adds padding bytes at the end to round it up.)
String s = new String(); 

char[] arr = {'a', 'b'};
String[] arr = new String[] {"One", "Two"};
String s = "ab";
String s = new String("ab");

List<T> l = new ArrayList<>();				// List<String>, HashMap<Integer, String>, Class<T>  examples of generics - these ensure type safety (avoid possible casting errors at runtime by shifting the check to compile time = "type erasure" = compiler resolves the generics into raw types using casting where needed, so there are no generics at runtime:
	List<String> list = new ArrayList<>();	---->
					List list = new ArrayList(); // generics erased 
					String s = (String) list.get(0); // compiler inserts cast

System.out.println(l.get(0) + " " + l.get(1) ) 		// ! toString() mechanism is activated if the get(Object) is called in connection with a String (thus the string literal "") 

-----------------------------------
String.valueOf(char c)	  --> String result
String.valueOf(char[] c)  --> String result
new String(char[] c)      --> String result
Integer.valueOf(int i)    --> Integer result
Integer.valueOf(String s)  --> string number to integer
Integer.intValue(Integer i) --> int result
Integer.max(int i, int y)

Collections.max(Collection C) -> Integer result

doube d = Math.random();	 --> generates a value between 0 incl. and 1 excl. Used for generating values between 0 and a number: e.g. Math.random() * 256 = generates between 0 and 255
Usage: e.g. print a random element from an array, 10 times: 
for (int i=0; i<10; i++){
int randomIndex = Math.random() * array.length;
System.out.println(array[randomIndex]);
}
-------------------------------------
String s2 = myString.substring(begin, end+1);
String s3 = s2.concat(s1)		 same as:   s1 + s2
StringBuilder sb = new StringBuilder(s2);
sb.append(s1);

String reverseStr = sb.reverse().toString();

Obtaining input from input stream (usually keyboard):
Scanner scan = new Scanner(System.in);   // ctrl + click on Scanner variable type (Scanner scan) opens class info doc
        int input = scan.nextInt();
	String input = scan.nextLine();



Print 1D array: 			
System.out.println(Arrays.toString(myArray)) 

Print 2D array of primitives/objects	
System.out.println(Arrays.deepToString(array2D))

Print line manually: 			System.out.print ("Hello\nWorld")   where "\n" stands for escape sign \ + new line shortcut
					System.out.print ("Hello" + "\n" + "World") 
\t → tab
\\ → literal backslash
\" → double quote

-----------------------------------
x appendAFunc, x Doubling xSum

copying arrays:
T[] copy = arr.clone()		// returns a shallow copy - new array but elements inside are the same than the original array. If elements are Objects, then by modifying the clone array elements, you would modify the original array too !

T[] arr2 = Arrays.copyOf(T[] arr1, length2)  //if length2 < length1, remaining elements are cut off. If length2 > lenght1, additional elements are assigned value equivalent 0 (primitives) or null (reference types(objects))

T[] arr2 = Arrays.copyOfRange(T[] arr1, indexFrom, indexTo+1)  //possible to copy starting from any arr element

Collections has only an overwrite-copy for List-type classes:
Collections.copy(List dest, List source);	// the destination must be >= in size and the elements of the dest. will be overwritten by the source elements at the respective indices

sorting non-manually:

Arrays.sort(arr[])
List.sort(Comparator.reverseOrder()) 
Collections.sort(myList)  --> Collections.reverse(myList)
Collections.shuffle(myList) 		// mixes the elements' order !!
List.stream().sorted() // sorted(Comparator.reverseOrder()) 

+ sort using lambdas: to fill in an anonymous function (parameters, body), by which we implement a functional interface(i. with exactly one abstract method). This is more lightweight on memory than implementing functional interfaces as JVM uses a lambda metafactory which produces fewer objects, lighter on memory. Lambdas(since Java 9) also bring functional programming (passing behavior as function argument)

.sorted( (a, b) -> {
	if (a>b){
	return 1;
	}else if (a==b){
	return 0;
	}else {return -1;}
}
)

@FunctionalInterface
interface Comparator {
public abstract int compare(int a, int b);
}

Comparator createAnonymousClassImplementingComparator = new Comparator() {
@Override
public int compare (int a, int b){
// write here the lambda expression body
}
}

-----------------
List<Integer> l = new ArrayList<>();
Object[] arr = l.toArray() 	-> returns Object[] !
Integer[] arr = l.toArray(new Integer[0])				returns Integer[] (no primitive parameters)

integerList.stream().mapToInt(Integer::intValue).toArray() 	returns int[] 	 intStream.toArray() != List.toArray()

List<String> l = new ArrayList<>(Arrays.asList(stringArr));
