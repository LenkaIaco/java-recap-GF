Review for repeating: Diagonal matrix + onwards

IntelliJ shortcuts:
sout + tab                      System.out.println()
main + tab			public static void main(String[] args){}
ctrl + alt + l                  automatic formatting
ctrl + click class name         opens documentation (class info)

char[] arr = new char[5];
int[] consumes less (4 bytes) memory than Integer[] (24–32 bytes: reference, object, int inside,padding-The JVM tries to place objects at memory addresses divisible by 8. If the object’s size is not a multiple of 8, the JVM adds padding bytes at the end to round it up.)
String s = new String(); 

char[] arr = {'a', 'b'};
String[] arr = new String[] {"One", "Two"};
String s = "ab";
String s = new String("ab");

-----------------------------------
String.valueOf(char c)	  --> String result
String.valueOf(char[] c)  --> String result
new String(char[] c)      --> String result
Integer.valueOf(int i)    --> Integer result
Integer.valueOf(String s)  --> string number to integer
Integer.intValue(Integer i) --> int result
-------------------------------------
String s2 = myString.substring(begin, end+1);
String s3 = s2.concat(s1)		 same as:   s1 + s2
StringBuilder sb = new StringBuilder(s2);
sb.append(s1);

String reverseStr = sb.reverse().toString();

Obtaining input from input stream (usually keyboard):
Scanner scan = new Scanner(System.in);   // ctrl + click on Scanner variable type (Scanner scan) opens class info doc
        int input = scan.nextInt();
	String input = scan.nextLine();



Print 1D array: 			System.out.println(Arrays.toString(myArray)) 
Print 2D array of primitives/objects	System.out.println(Arrays.deepToString(array2D))

Print line manually: 			System.out.print ("Hello\nWorld")   where "\n" stands for escape sign \ + new line shortcut
					System.out.print ("Hello" + "\n" + "World") 
\t → tab
\\ → literal backslash
\" → double quote

-----------------------------------
x appendAFunc, x Doubling xSum

copying arrays:

T[] arr2 = Arrays.copyOf(T[] arr1, length2)  //if length2 < length1, remaining elements are cut off. If length2 > lenght1, additional elements are assigned value equivalent 0 (primitives) or null (reference types(objects))

T[] arr2 = Arrays.copyOfRange(T[] arr1, indexFrom, indexTo+1)  //possible to copy starting from any arr element

Collections has only an overwrite-copy for List-type classes:
Collections.copy(List dest, List source);	// the destination must be >= in size and the elements of the dest. will be overwritten by the source elements at the respective indices

sorting non-manually:

Arrays.sort(arr[])
List.sort(Comparator.reverseOrder()) 
Collections.sort(myList)  --> Collections.reverse(myList)
List.stream().sorted() // sorted(Comparator.reverseOrder()) 

+ sort using lambdas: to fill in an anonymous function (parameters, body), by which we implement a functional interface(i. with exactly one abstract method). This is more lightweight on memory than implementing functional interfaces as JVM uses a lambda metafactory which produces fewer objects, lighter on memory. Lambdas(since Java 9) also bring functional programming (passing behavior as function argument)

.sorted( (a, b) -> {
if (a>b){
return 1;
}else if (a==b){
return 0;
}else {return -1;}
}
)

@FunctionalInterface
interface Comparator {
public abstract int compare(int a, int b);
}

Comparator createAnonymousClassImplementingComparator = new Comparator() {
@Override
public int compare (int a, int b){
// write here the lambda expression body
}
}

-----------------
List<Integer> l = new ArrayList<>();
Object[] arr = l.toArray() 	-> returns Object[] !
Integer[] arr = l.toArray(new Integer[0])				returns Integer[] (no primitive parameters)

integerList.stream().mapToInt(Integer::intValue).toArray() 	returns int[] 	 intStream.toArray() != List.toArray()

List<String> l = new ArrayList<>(Arrays.asList(stringArr));
